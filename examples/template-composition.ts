/**
 * Template Composition Example - Advanced Handlebars Patterns
 * 
 * This example demonstrates:
 * - Partials for reusable template fragments
 * - Template inheritance with layouts
 * - Dynamic component generation from data
 * - Conditional imports based on feature flags
 * - Custom helpers for complex logic
 * - Nested templates with context passing
 */

import {
  registerTemplate,
  registerPartial,
  renderTemplate,
  createCustomHelper,
  formatTypeScript,
  type TemplateData,
} from '@dcyfr/ai-code-gen';
import Handlebars from 'handlebars';

// ============================================================================
// 1. Register Reusable Partials
// ============================================================================

// File header partial
registerPartial('file-header', `/**
 * {{description}}
 * 
 * @generated by @dcyfr/ai-code-gen
 * @date {{timestamp}}
 */
`);

// React import partial
registerPartial('import-react', `import React{{#if hooks}}, { {{join hooks ', '}} }{{/if}} from 'react';`);

// TypeScript interface property partial
registerPartial('interface-property', `  {{name}}{{#unless required}}?{{/unless}}: {{type}};{{#if description}} // {{description}}{{/if}}`);

// Function JSDoc partial
registerPartial('function-jsdoc', `/**
 * {{description}}
 {{#each params}}
 * @param {{name}} - {{description}}
 {{/each}}
 * @returns {{returns}}
 */`);

// ============================================================================
// 2. Template Inheritance - Base Layout
// ============================================================================

registerTemplate({
  id: 'base-layout',
  name: 'Base TypeScript File Layout',
  description: 'Base template for TypeScript files with header and exports',
  variables: {
    fileName: { type: 'string', required: true },
    description: { type: 'string', required: true },
    imports: { type: 'array', required: false },
    content: { type: 'string', required: true },
    exports: { type: 'array', required: false },
  },
  source: `
{{> file-header description=description}}

{{#if imports}}
{{#each imports}}
{{{this}}}
{{/each}}

{{/if}}
{{{content}}}

{{#if exports}}

// Exports
{{#each exports}}
export { {{this}} };
{{/each}}
{{/if}}
  `.trim(),
});

// ============================================================================
// 3. Complex Component Generator with Partials
// ============================================================================

registerTemplate({
  id: 'advanced-component',
  name: 'Advanced React Component',
  description: 'Generate React component with hooks, props validation, and documentation',
  variables: {
    name: { type: 'string', required: true },
    description: { type: 'string', required: true },
    props: { type: 'array', required: true },
    hooks: { type: 'array', required: false },
    methods: { type: 'array', required: false },
    useClient: { type: 'boolean', required: false },
  },
  source: `
{{#if useClient}}'use client';

{{/if}}{{> import-react hooks=hooks}}

// Props Interface
interface {{pascalCase name}}Props {
{{#each props}}
{{> interface-property name=name type=type required=required description=description}}
{{/each}}
}

{{> function-jsdoc description=description params=props returns=(concat (pascalCase name) ' component')}}
export function {{pascalCase name}}({{#if props}}{ {{#each props}}{{name}}{{#unless @last}}, {{/unless}}{{/each}} }: {{pascalCase name}}Props{{/if}}) {
{{#each hooks}}
  {{this}}
{{/each}}

{{#each methods}}
  {{{this}}}
{{/each}}

  return (
    <div className="{{kebabCase name}}">
      {/* Component content */}
    </div>
  );
}
  `.trim(),
});

// ============================================================================
// 4. Conditional Imports Template
// ============================================================================

interface FeatureFlags {
  useAuth: boolean;
  useDatabase: boolean;
  useValidation: boolean;
  useLogging: boolean;
}

function generateImportsWithFlags(flags: FeatureFlags): string {
  const templateSource = `
{{#if useAuth}}
import { authenticate, authorize } from '@/lib/auth';
{{/if}}
{{#if useDatabase}}
import { db } from '@/lib/database';
{{/if}}
{{#if useValidation}}
import { z } from 'zod';
{{/if}}
{{#if useLogging}}
import { logger } from '@/lib/logger';
{{/if}}
  `.trim();
  
  const template = Handlebars.compile(templateSource);
  return template(flags);
}

// ============================================================================
// 5. Dynamic Method Generation from Data
// ============================================================================

interface MethodDefinition {
  name: string;
  params: Array<{ name: string; type: string }>;
  returnType: string;
  body: string;
}

function generateMethods(methods: MethodDefinition[]): string {
  const templateSource = `
{{#each methods}}
  {{name}}({{#each params}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{returnType}} {
    {{{body}}}
  }
{{/each}}
  `.trim();
  
  const template = Handlebars.compile(templateSource);
  return template({ methods });
}

// ============================================================================
// 6. Nested Template Composition - Full Module
// ============================================================================

interface ModuleData {
  name: string;
  description: string;
  interfaces: Array<{
    name: string;
    properties: Array<{ name: string; type: string; required: boolean; description?: string }>;
  }>;
  classes: Array<{
    name: string;
    implements?: string;
    methods: MethodDefinition[];
  }>;
  exports: string[];
}

async function generateModule(data: ModuleData): Promise<string> {
  // Generate interfaces
  const interfacesCode = data.interfaces.map(iface => {
    const propsTemplate = Handlebars.compile(`
interface {{name}} {
{{#each properties}}
{{> interface-property name=name type=type required=required description=description}}
{{/each}}
}
    `.trim());
    
    return propsTemplate(iface);
  }).join('\n\n');
  
  // Generate classes
  const classesCode = data.classes.map(cls => {
    const classTemplate = Handlebars.compile(`
export class {{name}}{{#if implements}} implements {{implements}}{{/if}} {
{{{methods}}}
}
    `.trim());
    
    return classTemplate({
      ...cls,
      methods: generateMethods(cls.methods),
    });
  }).join('\n\n');
  
  // Compose full module using base layout
  const content = `${interfacesCode}\n\n${classesCode}`;
  
  return renderTemplate('base-layout', {
    fileName: `${data.name}.ts`,
    description: data.description,
    imports: [],
    content,
    exports: data.exports,
  });
}

// ============================================================================
// 7. Custom Helper - Generate CRUD Methods
// ============================================================================

Handlebars.registerHelper('generateCrudMethods', function(entityName: string) {
  const entity = entityName.toLowerCase();
  const Entity = entityName;
  
  return `
  async findAll(): Promise<${Entity}[]> {
    return this.repository.findAll();
  }

  async findById(id: string): Promise<${Entity} | null> {
    return this.repository.findById(id);
  }

  async create(data: Create${Entity}Dto): Promise<${Entity}> {
    this.validate(data);
    return this.repository.create(data);
  }

  async update(id: string, data: Update${Entity}Dto): Promise<${Entity}> {
    await this.findById(id); // Ensure exists
    this.validate(data);
    return this.repository.update(id, data);
  }

  async delete(id: string): Promise<void> {
    await this.findById(id); // Ensure exists
    await this.repository.delete(id);
  }

  private validate(data: any): void {
    // Validation logic here
  }
  `.trim();
});

// ============================================================================
// 8. Template with Data Transformation
// ============================================================================

interface FormField {
  name: string;
  type: 'text' | 'email' | 'number' | 'select' | 'checkbox';
  label: string;
  required: boolean;
  validation?: string;
  options?: string[];
}

function generateFormComponent(fields: FormField[]): string {
  // Transform field data for template
  const fieldConfig = fields.map(field => ({
    ...field,
    zodType: mapFieldTypeToZod(field.type),
    inputType: field.type === 'checkbox' ? 'checkbox' : field.type === 'select' ? 'select' : 'input',
  }));
  
  const templateSource = `
'use client';

import React, { useState } from 'react';
import { z } from 'zod';

// Validation Schema
const formSchema = z.object({
{{#each fields}}
  {{name}}: z.{{zodType}}(){{#if required}}.min(1, '{{label}} is required'){{/if}}{{#if validation}}.{{validation}}{{/if}},
{{/each}}
});

type FormData = z.infer<typeof formSchema>;

export function GeneratedForm() {
  const [formData, setFormData] = useState<FormData>({
{{#each fields}}
    {{name}}: {{#if (eq type 'checkbox')}}false{{else if (eq type 'number')}}0{{else}}''{{/if}},
{{/each}}
  });
  const [errors, setErrors] = useState<Partial<Record<keyof FormData, string>>>({});

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      const validated = formSchema.parse(formData);
      console.log('Form submitted:', validated);
      setErrors({});
    } catch (error) {
      if (error instanceof z.ZodError) {
        const fieldErrors: Partial<Record<keyof FormData, string>> = {};
        error.errors.forEach(err => {
          if (err.path[0]) {
            fieldErrors[err.path[0] as keyof FormData] = err.message;
          }
        });
        setErrors(fieldErrors);
      }
    }
  };

  return (
    <form onSubmit={handleSubmit}>
{{#each fields}}
      <div>
        <label htmlFor="{{name}}">{{label}}{{#if required}} *{{/if}}</label>
{{#if (eq inputType 'input')}}
        <input
          id="{{name}}"
          type="{{type}}"
          value={formData.{{name}}}
          onChange={(e) => setFormData({ ...formData, {{name}}: e.target.value })}
        />
{{else if (eq inputType 'select')}}
        <select
          id="{{name}}"
          value={formData.{{name}}}
          onChange={(e) => setFormData({ ...formData, {{name}}: e.target.value })}
        >
{{#each options}}
          <option value="{{this}}">{{this}}</option>
{{/each}}
        </select>
{{else if (eq inputType 'checkbox')}}
        <input
          id="{{name}}"
          type="checkbox"
          checked={formData.{{name}}}
          onChange={(e) => setFormData({ ...formData, {{name}}: e.target.checked })}
        />
{{/if}}
        {errors.{{name}} && <span className="error">{errors.{{name}}}</span>}
      </div>
{{/each}}
      <button type="submit">Submit</button>
    </form>
  );
}
  `.trim();
  
  const template = Handlebars.compile(templateSource);
  return template({ fields: fieldConfig });
}

function mapFieldTypeToZod(type: string): string {
  switch (type) {
    case 'email': return 'string().email()';
    case 'number': return 'number()';
    case 'checkbox': return 'boolean()';
    default: return 'string()';
  }
}

// ============================================================================
// 9. Main Example Runner
// ============================================================================

async function main() {
  console.log('='.repeat(80));
  console.log('Template Composition Examples');
  console.log('='.repeat(80));
  
  // Example 1: Simple component with partials
  console.log('\n1. Advanced Component with Partials\n');
  
  const componentCode = await renderTemplate('advanced-component', {
    name: 'UserCard',
    description: 'Displays user information in a card format',
    useClient: true,
    props: [
      { name: 'userId', type: 'string', required: true, description: 'User ID' },
      { name: 'showAvatar', type: 'boolean', required: false, description: 'Show user avatar' },
      { name: 'onUpdate', type: '(user: User) => void', required: false, description: 'Update callback' },
    ],
    hooks: [
      "const [user, setUser] = useState<User | null>(null);",
      "const [loading, setLoading] = useState(false);",
    ],
    methods: [
      "const fetchUser = async () => { /* ... */ };",
      "const handleUpdate = () => { if (onUpdate && user) onUpdate(user); };",
    ],
  });
  
  console.log(formatTypeScript(componentCode));
  
  // Example 2: Conditional imports
  console.log('\n2. Conditional Imports Based on Feature Flags\n');
  
  const importsCode = generateImportsWithFlags({
    useAuth: true,
    useDatabase: true,
    useValidation: true,
    useLogging: false,
  });
  
  console.log(importsCode);
  
  // Example 3: Full module composition
  console.log('\n3. Full Module with Nested Templates\n');
  
  const moduleCode = await generateModule({
    name: 'UserService',
    description: 'User service with repository pattern',
    interfaces: [
      {
        name: 'IUser',
        properties: [
          { name: 'id', type: 'string', required: true },
          { name: 'name', type: 'string', required: true },
          { name: 'email', type: 'string', required: true },
        ],
      },
      {
        name: 'IUserRepository',
        properties: [
          { name: 'findAll', type: '() => Promise<IUser[]>', required: true },
          { name: 'findById', type: '(id: string) => Promise<IUser | null>', required: true },
        ],
      },
    ],
    classes: [
      {
        name: 'UserService',
        implements: 'IUserRepository',
        methods: [
          {
            name: 'findAll',
            params: [],
            returnType: 'Promise<IUser[]>',
            body: 'return this.repository.findAll();',
          },
          {
            name: 'findById',
            params: [{ name: 'id', type: 'string' }],
            returnType: 'Promise<IUser | null>',
            body: 'return this.repository.findById(id);',
          },
        ],
      },
    ],
    exports: ['UserService', 'IUser', 'IUserRepository'],
  });
  
  console.log(moduleCode.split('\n').slice(0, 30).join('\n'));
  console.log('... (truncated)\n');
  
  // Example 4: Custom helper for CRUD methods
  console.log('\n4. Custom Helper - Generate CRUD Methods\n');
  
  const crudTemplate = Handlebars.compile(`
export class {{name}}Service {
  constructor(private repository: I{{name}}Repository) {}

{{generateCrudMethods name}}
}
  `.trim());
  
  const crudCode = crudTemplate({ name: 'Product' });
  console.log(formatTypeScript(crudCode));
  
  // Example 5: Form generation with data transformation
  console.log('\n5. Dynamic Form Component Generation\n');
  
  const formFields: FormField[] = [
    { name: 'name', type: 'text', label: 'Full Name', required: true },
    { name: 'email', type: 'email', label: 'Email', required: true },
    { name: 'age', type: 'number', label: 'Age', required: false, validation: 'min(18)' },
    { name: 'country', type: 'select', label: 'Country', required: true, options: ['USA', 'UK', 'Canada'] },
    { name: 'newsletter', type: 'checkbox', label: 'Subscribe to newsletter', required: false },
  ];
  
  const formCode = generateFormComponent(formFields);
  console.log(formCode.split('\n').slice(0, 40).join('\n'));
  console.log('... (truncated)\n');
  
  console.log('\n' + '='.repeat(80));
  console.log('All template composition examples completed successfully!');
  console.log('='.repeat(80));
}

// Run examples
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(console.error);
}

export {
  generateImportsWithFlags,
  generateMethods,
  generateModule,
  generateFormComponent,
};
